<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[同步和异步]]></title>
      <url>http://xf2e.github.io/2016/10/12/sync_async/</url>
      <content type="html"><![CDATA[<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><blockquote>
<p>JavaScript语言的执行环境是”单线程”（single thread）。<br>所谓”单线程”，就是指一次只能完成一件任务。<br>如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推。</p>
<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；<br>坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。<br>常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），<br>导致整个页面卡在这个地方，其他任务无法执行。</p>
</blockquote>
<p><strong>为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。</strong></p>
<h3 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">同步模式：就是后一个任务等待前一个任务结束，</div><div class="line">然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</div></pre></td></tr></table></figure>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>同步模式，即阻塞模式，会阻止浏览器的后续处理，停止了后续的解析，因此停止了后续的文件加载（如图像）、渲染、代码执行。<br> js 之所以要同步执行，是因为js中可能有输出document内容、修改dom、重定向等行为，所以默认同步执行才是安全的。<br>一般建议是把<code>&lt;script&gt;</code>放在页面末尾<code>&lt;/body&gt;</code>之前，这样尽可能减少这种阻塞行为，而先让页面展示出来。</p>
<h3 id="异步模式"><a href="#异步模式" class="headerlink" title="异步模式"></a>异步模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">异步模式：每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执</div><div class="line">行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的</div><div class="line">执行顺序与任务的排列顺序是不一致的、异步的。</div></pre></td></tr></table></figure>
<p><em><code>异步模式</code>又叫非阻塞。在web端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子<br>就是Ajax操作。在js写server中，<code>异步模式</code>甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">异步调用并不会阻止代码的顺序执行，而是在将来的某一个时刻触发设置好的逻辑，所以我们</div><div class="line">并不知道逻辑什么时候会被调用</div><div class="line">只能定义当触发的时候逻辑是什么</div><div class="line">只能等待，同时可以去处理其他的逻辑</div><div class="line">异步函数，如setTimeout和setInterval，是被压入了称之为Event Loop的队列。</div><div class="line">Event Loop是一个回调函数队列。当异步函数执行时，回调函数会被压入这个队列。JavaScript引擎</div><div class="line">直到异步函数执行完成后，才会开始处理事件循环。这意味着JavaScript代码不是多线程的，即使表现</div><div class="line">的行为相似。事件循环是一个先进先出（FIFO）队列，这说明回调是按照它们被加入队列的顺序执行的。</div><div class="line">JavaScript被node选做为开发语言，就是因为写这样的代码多么简单啊。</div></pre></td></tr></table></figure></p>
<h4 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;./script.js&quot; async&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>浏览器在下载执行 js 同时，还会继续进行后续页面的处理。<br>这种方法是在页面中<code>&lt;script&gt;</code>标签内，设置async属性，async属性是HTML5中新增的异步支持。</p>
<p><strong>but</strong>这种加载方式在加载执行完之前会阻止 onload 事件的触发，而现在很多页面的代码都在 onload 时还要执行额外的渲染工作等，所以还是会阻塞部分页面的初始化处理。</p>
<p><strong>ps</strong>不管是同步加载还是异步加载,浏览器在下载完 js 的内容后就会立即对其解析和执行。<br>异步加载，解决的只是下载阶段的问题，但代码在下载后会立即执行。<br>浏览器在解析执行 JS 阶段是阻塞任何操作的，这时的浏览器处于无响应状态。<br>下载 script 需要明显的时间，但容易忽略了第二阶段，解析和执行也是需要时间的。script的解析和执行所花的时间比我们想象的要多，尤其是script 很多很大的时候。有些是需要立刻执行，而有些则不需要（比如只是在展示某个界面或执行某个操作时才需要）。<strong>*注：</strong>如何在第一次需要的时候再执行。感兴趣的可以看看<code>ControlJS</code> *</p>
<h4 id="处理异步代码"><a href="#处理异步代码" class="headerlink" title="处理异步代码"></a>处理异步代码</h4><h5 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h5><p>这种异步的方式是最基础的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> fs.readFile(fileA, function (err, data) &#123;</div><div class="line">  fs.readFile(fileB, function (err, data) &#123;</div><div class="line">    // ...</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果涉及到多个这样的异步操作，会有复杂的回调嵌套，就是传说中的回调地狱。</p>
<h6 id="避免这种回调地狱"><a href="#避免这种回调地狱" class="headerlink" title="避免这种回调地狱"></a>避免这种回调地狱</h6><ul>
<li>命名函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">清除嵌套回调的一个便捷的解决方案是简单的避免双层以上的嵌套。</div><div class="line">传递一个命名函数给作为回调参数，而不是传递匿名函数。</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p><a href="">点这里查看详情</a></p>
<h5 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h5><p><a href="">点这里查看详情</a></p>
<h5 id="await-async"><a href="#await-async" class="headerlink" title="await/async"></a>await/async</h5><p><a href="">点这里查看详情</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之原型模式]]></title>
      <url>http://xf2e.github.io/2016/09/18/designPatterns_prototype/</url>
      <content type="html"><![CDATA[<h2 id="原型模式概念"><a href="#原型模式概念" class="headerlink" title="原型模式概念"></a>原型模式概念</h2><img src="http://odn6bfovg.bkt.clouddn.com/1200px-Prototype_UML.svg.png" class="full-image" alt="alt" title="title">
<blockquote>
<p>原型模式（prototype）是创建型模式的一种,其特点在于通过「复制」一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的「原型」，这个原型是可定制的。<br><a id="more"></a><br>原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p>
<p>真正的原型继承是作为最新版的ECMAScript5标准提出的，使用Object.create方法来创建这样的对象，该方法创建指定的对象，其对象的prototype有指定的对象（也就是该方法传进的第一个参数对象），也可以包含其他可选的指定属性。例如Object.create(prototype, optionalDescriptorObjects)</p>
</blockquote>
<h3 id="Show-code"><a href="#Show-code" class="headerlink" title="Show code"></a>Show code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 因为不是构造函数，所以不用大写</div><div class="line">var girl = &#123;</div><div class="line">    name:&apos;郝阿由&apos;,//小孩的姓名</div><div class="line">    weight:&apos;7斤八两&apos; //小孩的体重</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使用Object.create创建一个女孩</div><div class="line">var bady = Object.create(girl);</div><div class="line">bady.name = &apos;郝美丽&apos;;</div><div class="line">Object.create运行你直接从其它对象继承过来，使用该方法的第二个参数，你可以初始化额外的其它属性。例如：</div><div class="line"></div><div class="line">var girl = &#123;</div><div class="line">    create: function () &#123;</div><div class="line">    return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var bady = Object.create(girl, &#123;</div><div class="line">    &apos;name&apos;: &#123;</div><div class="line">        value:&quot;郝美丽&quot;,</div><div class="line">        enumerable: true // 默认writable:false, configurable:false</div><div class="line"> &#125;,</div><div class="line">    &apos;weight&apos;: &#123;</div><div class="line">        value: &apos;7斤八两&apos;,</div><div class="line">        enumerable: true</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><em>这里，可以在Object.create的第二个参数里使用对象字面量传入要初始化的额外属性，其语法与Object.defineProperties或Object.defineProperty方法类型。它允许您设定属性的特性，例如enumerable, writable 或 configurable。</em></p>
<ul>
<li>如果你希望自己去实现原型模式，而不直接使用Object.create 。结合构造函数模式，把上面的代码重新实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Baby(data)&#123;</div><div class="line">    if(!(this instanceof Baby))&#123;</div><div class="line">        return new Baby(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.name=data.name||&apos;郝阿由&apos;; //小孩的姓名</div><div class="line">    this.weight=data.weight||&apos;7斤八两&apos;; //小孩的体重</div><div class="line"></div><div class="line">&#125;</div><div class="line">Baby.prototype.create= function () &#123;</div><div class="line">    return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var baby=new Baby(&#123;&#125;);</div><div class="line">console.log( baby.create());</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之构造函数模式]]></title>
      <url>http://xf2e.github.io/2016/09/18/designPatterns_constructed/</url>
      <content type="html"><![CDATA[<h2 id="构造函数模式概念"><a href="#构造函数模式概念" class="headerlink" title="构造函数模式概念"></a>构造函数模式概念</h2><blockquote>
<p>构造函数用于创建特定类型的对象–不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。<br><a id="more"></a><br>在JavaScript里，构造函数通常认为用来实现实例的，JavaScript没有类的概念，但是有特殊的构造函数。通过new关键字来调用自定义的构造函数在构造函数内部，this关键字引用的是新创建的对象。</p>
</blockquote>
<h3 id="Show-code"><a href="#Show-code" class="headerlink" title="Show code"></a>Show code</h3><p><code>需求:</code><em>我年纪大了，想有个小孩，1.这个小孩是我自己私有的，不要对谁都叫爸爸；2.我可能还要二胎，但是第二个小孩，但是我还没有想好这个小孩的名字。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Baby(data)&#123;</div><div class="line">    if(!(this instanceof Baby))&#123;</div><div class="line">        return new Baby(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.name=data.name||&apos;郝阿由&apos;; //小孩的姓名</div><div class="line">    this.weight=data.weight||&apos;7斤八两&apos;; //小孩的体重</div><div class="line">    this._create=create;</div><div class="line"></div><div class="line">&#125;</div><div class="line">function create() &#123;</div><div class="line">   return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var baby=new Baby(&#123;&#125;);</div><div class="line">console.log( baby._create());</div></pre></td></tr></table></figure>
<h3 id="Review一下"><a href="#Review一下" class="headerlink" title="Review一下"></a>Review一下</h3><ul>
<li>函数名首字母大写，用来区分构造函数和普通函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function Baby(data)</div></pre></td></tr></table></figure>
<ul>
<li>强制使用new，如果不用new，会把函数中this指到全局对象window上，如<code>var baby=Baby()</code>中baby 的type 是undefined，用window对象却可以调用构造函数Baby中的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(!(this instanceof Baby))&#123;</div><div class="line">        return new Baby(data);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>有的人可能会这样写 <code>this.create= function () { return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;};</code> ，这样写有一个问题，就是create()在每次创建对象的时候都重新定义，最好的方法是让所有baby类型的实例都共享这个create()方法， <strong>还有一种实现更好的办法，在原型模式中会聊到</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> this._create=create;</div><div class="line"></div><div class="line">&#125;</div><div class="line">function create() &#123;</div><div class="line">   return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="By-the-way"><a href="#By-the-way" class="headerlink" title="By the way"></a>By the way</h3><blockquote>
<p>JavaScript里有3中内置包装构造函数：Boolean(), String(), Number()</p>
<p>只有在想保留数值状态的时候使用这些包装函数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var s = &quot;s&quot;;//一个字符串</div><div class="line"></div><div class="line">s.name = &quot;s&quot;;</div><div class="line">//对包装对象加了一个方法，执行完毕后立即销毁，第三行读不到 （聊ECMAScript时，会讲为什么）</div><div class="line">console.log(typeof s.name); // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var s = new String(&quot;s&quot;);//一个对象 </div><div class="line"></div><div class="line">s.name = &quot;s&quot;;</div><div class="line">// 可以正常访问新属性</div><div class="line">console.log(typeof s.name); // &quot;boolean&quot;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之中介者模式]]></title>
      <url>http://xf2e.github.io/2016/09/18/designPAatterns_mediator/</url>
      <content type="html"><![CDATA[<h2 id="中介者模式概念"><a href="#中介者模式概念" class="headerlink" title="中介者模式概念"></a>中介者模式概念</h2><blockquote>
<p>中介者模式（Mediator），用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><a id="more"></a><br>中介者是一个行为设计模式，通过提供一个统一的接口让系统的不同部分进行通信。一般，如果系统有很多子模块需要直接沟通，都要创建一个中央控制点让其各模块通过该中央控制点进行交互。中介者模式可以让这些子模块不需要直接沟通，而达到进行解耦的目的。</p>
<p>打个比方，平时常见的机场交通控制系统，塔台就是中介者，它控制着飞机（子模块）的起飞和降落，因为所有的沟通都是从飞机向塔台汇报来完成的，而不是飞机之前相互沟通。中央控制系统就是该系统的关键，也就是软件设计中扮演的中介者角色。</p>
<h3 id="Show-code"><a href="#Show-code" class="headerlink" title="Show code"></a>Show code</h3></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">   function Airplane(name)&#123;</div><div class="line">    if (!(this instanceof Airplane )) &#123;</div><div class="line">        return new Airplane(name);</div><div class="line">    &#125;</div><div class="line">        this.name=name;</div><div class="line">  &#125;;</div><div class="line">  Airplane.prototype.send=function(msg,to)&#123;</div><div class="line">        tower.send(msg,to);</div><div class="line">  &#125;;</div><div class="line">  Airplane.prototype.receive=function(msg)&#123;</div><div class="line">        console.log(this.name+&quot;【接收到】&quot;+msg);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  var tower=&#123;</div><div class="line">        all:&#123;&#125;,</div><div class="line">        init:function (airplane) &#123;</div><div class="line">            this.all[airplane.name]=airplane;</div><div class="line">        &#125;,</div><div class="line">        send:function (msg,to) &#123;</div><div class="line">            this.all[to.name].receive(msg);</div><div class="line">        &#125;</div><div class="line">  &#125;;</div><div class="line">var airplane1=new Airplane(&quot;airplane1&quot;),</div><div class="line">    airplane2=new Airplane(&quot;airplane2&quot;);</div><div class="line">tower.signIn(airplane1);</div><div class="line">tower.signIn(airplane2);</div><div class="line">airplane1.send(&quot;我还有二百米就要降落了&quot;,airplane2);</div></pre></td></tr></table></figure>
<p><em>中介者模式一般应用于一组对象已定义良好但是以复杂的方式进行通信的场合，一般情况下，中介者模式很容易在系统中使用，但也容易在系统里误用，当系统出现了多对多交互复杂的对象群时，先不要急于使用中介者模式，而是要思考一下是不是系统设计有问题。</em></p>
<p><em>另外，由于中介者模式把交互复杂性变成了中介者本身的复杂性，所以说中介者对象会比其它任何对象都复杂</em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>http://xf2e.github.io/2016/09/18/designPatterns_singleton/</url>
      <content type="html"><![CDATA[<h2 id="单例模式概念"><a href="#单例模式概念" class="headerlink" title="单例模式概念"></a>单例模式概念</h2><p>单例模式，在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br><a id="more"></a><br>在JavaScript里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var girl = &#123;</div><div class="line">    name:&apos;郝阿由&apos;,//小孩的姓名</div><div class="line">    weight:&apos;7斤八两&apos;, //小孩的体重</div><div class="line">    create:function () &#123;</div><div class="line">        return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果以后要扩展该对象，你可以添加自己的私有成员和方法，然后使用闭包在其内部封装这些变量和函数声明。只暴露你想暴露的public成员和方法，并且在使用的时候才初始化,为了节约资源的目的，我们可以另外一个构造函数里来初始化这些代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">var Babytest=(function () &#123;</div><div class="line">    // body...</div><div class="line"></div><div class="line"></div><div class="line">    function Baby(data)&#123;</div><div class="line">        if(!(this instanceof Baby))&#123;</div><div class="line">            return new Baby(data);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        this.name=data.name||&apos;郝阿由&apos;; //小孩的姓名</div><div class="line">        this.weight=data.weight||&apos;7斤八两&apos;; //小孩的体重</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    Baby.prototype.create= function () &#123;</div><div class="line">        return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">     //实例容器</div><div class="line">    var instance;</div><div class="line"></div><div class="line">    var _static = &#123;</div><div class="line">        name: &apos;Babytest&apos;,</div><div class="line"></div><div class="line">        //获取实例的方法</div><div class="line">        //返回Baby的实例</div><div class="line">        getInstance: function (args) &#123;</div><div class="line">            if (instance === undefined) &#123;</div><div class="line">                instance = new Baby(args);</div><div class="line">            &#125;</div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    return _static;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var baby=Babytest.getInstance(&#123;name:&quot;郝美丽&quot;&#125;);</div><div class="line">console.log( baby.create());</div></pre></td></tr></table></figure>
<p><em>单例一般是用在系统间各种模式的通信协调上</em></p>
]]></content>
    </entry>
    
  
  
</search>
