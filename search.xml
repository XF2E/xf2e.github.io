<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[设计模式之原型模式]]></title>
      <url>http://xf2e.github.io/2016/09/18/designPatterns_prototype/</url>
      <content type="html"><![CDATA[<h2 id="原型模式概念"><a href="#原型模式概念" class="headerlink" title="原型模式概念"></a>原型模式概念</h2><img src="http://odn6bfovg.bkt.clouddn.com/1200px-Prototype_UML.svg.png" class="full-image" alt="alt" title="title">
<a id="more"></a>
<blockquote>
<p>原型模式（prototype）是创建型模式的一种,其特点在于通过「复制」一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的「原型」，这个原型是可定制的。</p>
<p>原型模式多用于创建复杂的或者耗时的实例，因为这种情况下，复制一个已经存在的实例使程序运行更高效；或者创建值相等，只是命名不一样的同类数据。</p>
<p>真正的原型继承是作为最新版的ECMAScript5标准提出的，使用Object.create方法来创建这样的对象，该方法创建指定的对象，其对象的prototype有指定的对象（也就是该方法传进的第一个参数对象），也可以包含其他可选的指定属性。例如Object.create(prototype, optionalDescriptorObjects)</p>
</blockquote>
<h3 id="Show-code"><a href="#Show-code" class="headerlink" title="Show code"></a>Show code</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 因为不是构造函数，所以不用大写</div><div class="line">var girl = &#123;</div><div class="line">    name:&apos;郝阿由&apos;,//小孩的姓名</div><div class="line">    weight:&apos;7斤八两&apos; //小孩的体重</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使用Object.create创建一个女孩</div><div class="line">var bady = Object.create(girl);</div><div class="line">bady.name = &apos;郝美丽&apos;;</div><div class="line">Object.create运行你直接从其它对象继承过来，使用该方法的第二个参数，你可以初始化额外的其它属性。例如：</div><div class="line"></div><div class="line">var girl = &#123;</div><div class="line">    create: function () &#123;</div><div class="line">    return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var bady = Object.create(girl, &#123;</div><div class="line">    &apos;name&apos;: &#123;</div><div class="line">        value:&quot;郝美丽&quot;,</div><div class="line">        enumerable: true // 默认writable:false, configurable:false</div><div class="line"> &#125;,</div><div class="line">    &apos;weight&apos;: &#123;</div><div class="line">        value: &apos;7斤八两&apos;,</div><div class="line">        enumerable: true</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><em>这里，可以在Object.create的第二个参数里使用对象字面量传入要初始化的额外属性，其语法与Object.defineProperties或Object.defineProperty方法类型。它允许您设定属性的特性，例如enumerable, writable 或 configurable。</em></p>
<ul>
<li>如果你希望自己去实现原型模式，而不直接使用Object.create 。结合构造函数模式，把上面的代码重新实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Baby(data)&#123;</div><div class="line">    if(!(this instanceof Baby))&#123;</div><div class="line">        return new Baby();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    this.name=data.name||&apos;郝阿由&apos;; //小孩的姓名</div><div class="line">    this.weight=data.weight||&apos;7斤八两&apos;; //小孩的体重</div><div class="line"></div><div class="line">&#125;</div><div class="line">Baby.prototype.create= function () &#123;</div><div class="line">    return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var baby=new Baby(&#123;&#125;);</div><div class="line">console.log( baby._create());</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之构造函数模式]]></title>
      <url>http://xf2e.github.io/2016/09/18/designPatterns_constructed/</url>
      <content type="html"><![CDATA[<h2 id="构造函数模式概念"><a href="#构造函数模式概念" class="headerlink" title="构造函数模式概念"></a>构造函数模式概念</h2><blockquote>
<p>构造函数用于创建特定类型的对象–不仅声明了使用的对象，构造函数还可以接受参数以便第一次创建对象的时候设置对象的成员值。你可以自定义自己的构造函数，然后在里面声明自定义类型对象的属性或方法。<br><a id="more"></a><br>在JavaScript里，构造函数通常认为用来实现实例的，JavaScript没有类的概念，但是有特殊的构造函数。通过new关键字来调用自定义的构造函数在构造函数内部，this关键字引用的是新创建的对象。</p>
</blockquote>
<h3 id="Show-code"><a href="#Show-code" class="headerlink" title="Show code"></a>Show code</h3><p><code>需求:</code><em>我年纪大了，想有个小孩，1.这个小孩是我自己私有的，不要对谁都叫爸爸；2.我可能还要二胎，但是第二个小孩，但是我还没有想好这个小孩的名字。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Baby(data)&#123;</div><div class="line">    if(!(this instanceof Baby))&#123;</div><div class="line">        return new Baby();</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    this.name=data.name||&apos;郝阿由&apos;; //小孩的姓名</div><div class="line">    this.weight=data.weight||&apos;7斤八两&apos;; //小孩的体重</div><div class="line">    this.badyCreate=create;</div><div class="line"></div><div class="line">&#125;</div><div class="line">function create() &#123;</div><div class="line">   return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var baby=new Baby(&#123;&#125;);</div><div class="line">console.log( baby._create());</div></pre></td></tr></table></figure>
<h3 id="Review一下"><a href="#Review一下" class="headerlink" title="Review一下"></a>Review一下</h3><ul>
<li>函数名首字母大写，用来区分构造函数和普通函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function Baby(data)</div></pre></td></tr></table></figure>
<ul>
<li>强制使用new，如果不用new，会把函数中this指到全局对象window上，如<code>var baby=Baby()</code>中baby 的type 是undefined，用window对象却可以调用构造函数Baby中的方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(!(this instanceof Baby))&#123;</div><div class="line">        return new Baby();</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>有的人可能会这样写 <code>this.create= function () { return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;};</code> ，这样写有一个问题，就是create()在每次创建对象的时候都重新定义，最好的方法是让所有baby类型的实例都共享这个create()方法， <strong>还有一种实现更好的办法，在原型模式中会聊到</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> this._create=create;</div><div class="line"></div><div class="line">&#125;</div><div class="line">function create() &#123;</div><div class="line">   return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="By-the-way"><a href="#By-the-way" class="headerlink" title="By the way"></a>By the way</h3><blockquote>
<p>JavaScript里有3中内置包装构造函数：Boolean(), String(), Number()</p>
<p>只有在想保留数值状态的时候使用这些包装函数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var s = &quot;s&quot;;//一个字符串 </div><div class="line"></div><div class="line">s.name = &quot;s&quot;;</div><div class="line">//对包装对象加了一个方法，执行完毕后立即销毁，第三行读不到 （聊ECMAScript时，会讲为什么）</div><div class="line">console.log(typeof s.name); // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var s = new String(&quot;s&quot;);//一个对象 </div><div class="line"></div><div class="line">s.name = &quot;s&quot;;</div><div class="line">// 可以正常访问新属性</div><div class="line">console.log(typeof s.name); // &quot;boolean&quot;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之中介者模式]]></title>
      <url>http://xf2e.github.io/2016/09/18/designPAatterns_mediator/</url>
      <content type="html"><![CDATA[<h2 id="中介者模式概念"><a href="#中介者模式概念" class="headerlink" title="中介者模式概念"></a>中介者模式概念</h2><blockquote>
<p>中介者模式（Mediator），用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><a id="more"></a><br>中介者是一个行为设计模式，通过提供一个统一的接口让系统的不同部分进行通信。一般，如果系统有很多子模块需要直接沟通，都要创建一个中央控制点让其各模块通过该中央控制点进行交互。中介者模式可以让这些子模块不需要直接沟通，而达到进行解耦的目的。</p>
<p>打个比方，平时常见的机场交通控制系统，塔台就是中介者，它控制着飞机（子模块）的起飞和降落，因为所有的沟通都是从飞机向塔台汇报来完成的，而不是飞机之前相互沟通。中央控制系统就是该系统的关键，也就是软件设计中扮演的中介者角色。</p>
<h3 id="Show-code"><a href="#Show-code" class="headerlink" title="Show code"></a>Show code</h3></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">   function Airplane(name)&#123;</div><div class="line">    if (!(this instanceof Airplane )) &#123;</div><div class="line">        return new Airplane();</div><div class="line">    &#125;</div><div class="line">        this.name=name;</div><div class="line">  &#125;;</div><div class="line">  Airplane.prototype.send=function(msg,to)&#123;</div><div class="line">        tower.send(msg,to);</div><div class="line">  &#125;;</div><div class="line">  Airplane.prototype.receive=function(msg)&#123;</div><div class="line">        console.log(this.name+&quot;【接收到】&quot;+msg);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  var tower=&#123;</div><div class="line">        all:&#123;&#125;,</div><div class="line">        init:function (airplane) &#123;</div><div class="line">            this.all[airplane.name]=airplane;</div><div class="line">        &#125;,</div><div class="line">        send:function (msg,to) &#123;</div><div class="line">            this.all[to.name].receive(msg);</div><div class="line">        &#125;</div><div class="line">  &#125;;</div><div class="line">var airplane1=new Airplane(&quot;airplane1&quot;),</div><div class="line">    airplane2=new Airplane(&quot;airplane2&quot;);</div><div class="line">tower.signIn(airplane1);</div><div class="line">tower.signIn(airplane2);</div><div class="line">airplane1.send(&quot;我还有二百米就要降落了&quot;,airplane2);</div></pre></td></tr></table></figure>
<p><em>中介者模式一般应用于一组对象已定义良好但是以复杂的方式进行通信的场合，一般情况下，中介者模式很容易在系统中使用，但也容易在系统里误用，当系统出现了多对多交互复杂的对象群时，先不要急于使用中介者模式，而是要思考一下是不是系统设计有问题。</em></p>
<p><em>另外，由于中介者模式把交互复杂性变成了中介者本身的复杂性，所以说中介者对象会比其它任何对象都复杂</em></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>http://xf2e.github.io/2016/09/18/designPatterns_singleton/</url>
      <content type="html"><![CDATA[<h2 id="单例模式概念"><a href="#单例模式概念" class="headerlink" title="单例模式概念"></a>单例模式概念</h2><p>单例模式，在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。<br><a id="more"></a><br>在JavaScript里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var girl = &#123;</div><div class="line">    name:&apos;郝阿由&apos;,//小孩的姓名</div><div class="line">    weight:&apos;7斤八两&apos;, //小孩的体重</div><div class="line">    create:function () &#123;</div><div class="line">        return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果以后要扩展该对象，你可以添加自己的私有成员和方法，然后使用闭包在其内部封装这些变量和函数声明。只暴露你想暴露的public成员和方法，并且在使用的时候才初始化,为了节约资源的目的，我们可以另外一个构造函数里来初始化这些代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">var Babytest=(function () &#123;</div><div class="line">    // body...</div><div class="line"></div><div class="line"></div><div class="line">    function Baby(data)&#123;</div><div class="line">        if(!(this instanceof Baby))&#123;</div><div class="line">            return new Baby();</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        this.name=data.name||&apos;郝阿由&apos;; //小孩的姓名</div><div class="line">        this.weight=data.weight||&apos;7斤八两&apos;; //小孩的体重</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    Baby.prototype.create= function () &#123;</div><div class="line">        return &quot;小孩的名字是&quot;+this.name+&quot;小孩的体重是&quot;+this.weight;</div><div class="line">    &#125;;</div><div class="line">   </div><div class="line"></div><div class="line">     //实例容器</div><div class="line">    var instance;</div><div class="line"></div><div class="line">    var _static = &#123;</div><div class="line">        name: &apos;Babytest&apos;,</div><div class="line"></div><div class="line">        //获取实例的方法</div><div class="line">        //返回Baby的实例</div><div class="line">        getInstance: function (args) &#123;</div><div class="line">            if (instance === undefined) &#123;</div><div class="line">                instance = new Baby(&#123;&#125;);</div><div class="line">            &#125;</div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    return _static;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var baby=Babytest.getInstance(&#123;name:&quot;郝美丽&quot;&#125;);</div><div class="line">console.log( baby.create());</div></pre></td></tr></table></figure>
<p><em>单例一般是用在系统间各种模式的通信协调上</em></p>
]]></content>
    </entry>
    
  
  
</search>
